<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Springboot 공부</title>
    <link rel="stylesheet" href="/styles.css">
</head>
<body>

<h2>REST API</h2>
1. Unifrom Interface: 비슷한 기능을 하는 API들은 URL과 method가 유사성, 일관성이 있어야 함.<br>
2. Client-server 역할 구분: 유저에게 서버역할을 맡기거나 DB를 직접 입출력하게 시키면 안좋음.<br>
3. Stateless: 요청들은 서로 의존성이 있으면 안되고 각각 독립적으로 처리.<br>
4. Cacheable: 서버가 보내는 자료들은 캐싱이 가능해야 함. 자주 받는 자료들은 브라우저에서 하드에 저장해놓고 서버에 요청을 날리는게 아니라 하드에서 뽑아쓰는 것이 캐싱.<br>
5. Layered System: 서버 기능을 만들 때 레이어를 걸쳐서 코드가 실행되도록 만들어도 됨.<br>
6. Code on demand: 서버는 실행가능한 코드를 보낼 수 있음.<br>
<br>

<h2>예쁜 URL 만들기</h2>
1. 동사보단 명사 위주로 구성<br>
2. 띄어쓰기는 언더바_대신 대시-기호-사용<br>
3. 파일 확장자 쓰지 말기 (.html)<br>
4. 하위 항목을 표현하고 싶으면 / 기호 사용<br>
ex) facebook.com/bbc/photos -> 페북에서 bbc 계정의 사진첩 보여줄거 같음<br>
<br>

<h2>Dependency Injection</h2>
@Autowired는 ItemRepository, ItemService 이름의 타입만 붙여둔 자리에 <br>
new ItemRepository(), new ItemService() 알아서 찾아와서 넣으라는 스프링 문법입니다. <br>
<br>
<h3>다른 클래스의 함수 사용하려면</h3>
new ItemService().saveItem() 해서 사용하면 뭔가 비효율적인 것 같지 않습니까<br>
왜냐면 /add로 요청이 들어올 때 마다 매번 new 키워드로 object를 뽑아야하니까요.<br>
그게 싫으면 그냥 object를 한 번 뽑고 그걸 변수에 저장해뒀다가 계속 재사용하는 식으로 코드짜도 됩니다.<br>
근데 그걸 여러분이 직접 코드로 구현해도 되겠지만 스프링에게 시킬 수도 있습니다.<br>
3-step이 필요한데<br>
1. 클래스에 @Service 붙여놓고<br>
2. 이 함수들 쓰고싶은 곳에 가서 변수로 등록하고<br>
3. 원하는 곳에서 변수.함수() 쓰면 됩니다.<br>
<br>
이런 식으로 코드짜는 패턴을 멋있는 개발자말로 dependency injection이라고 합니다. <br>
다른 클래스의 변수, 함수를 사용할 때 <br>
new 클래스().함수() 이렇게 매번 쓰는게 아니라 <br>
new 클래스()를 다른데서 미리 뽑아놓은 다음에 <br>
그것만 파라미터로 집어넣어서 쓰게 만드는걸 dependency injection이라고 부릅니다. <br>
<br>
장점1. 매번 object를 뽑아쓰지 않아도 되니까 성능상 효율적임 <br>
이러면 API가 실행될 때 마다 object를 새로 뽑을 필요가 없습니다. <br>
object를 하나만 뽑아놓고 계속 재사용하는걸 싱글톤 패턴이라고 부르기도 합니다. <br>
<br>
장점2. 클래스간의 연결고리를 줄일 수 있습니다. <br>
클래스간의 커플링을 줄여서 클래스들을 서로 독립적으로 깔끔하게 유지할 수 있어서 쓰는 이유도 있습니다. <br>
클래스1에서 new 클래스2(); 하면 클래스간에 커플링이 생긴다고 합니다. <br>
이러면 나중에 클래스2가 변경되면 그걸 쓰는 클래스1도 찾아가서 변경해야합니다. <br>
그래서 커플링을 줄이면 관리가 편해질 수 있습니다. <br>
<br>

<h2>Container, Bean이라는 용어 </h2>
스프링이 몰래 object를 하나 뽑아서 알아서 집어넣어준다고 했는데<br>
근데 스프링이 object를 뽑아서 보관하는 공간 같은게 있을 것이다.<br>
그걸 Container 아니면 IOC Container라고 부릅니다.<br>
거기 안에 들어있는 object들을 Spring의 Bean이라고 부릅니다.<br>
<br>
참고로 @Service, @Component 이런걸 클래스에 붙여놓으면<br>
"서버가 실행될 때 @Service, @Component 붙은 클래스의 object를 뽑아서 Container안에 담아놓으라"는 뜻입니다.<br>
그리고 그 때 스프링이 뽑아준 object가 Bean입니다.<br>
<br>

<h2>여러가지 Exception</h2>
RuntimeException 보다 더 정확한걸 쓰는게 좋은데<br>
들어온 값이 더러우면 MethodArgumentNotValidException, IllegalArgumentException<br>
URL이 이상하면 MissingServletRequestParameterException, NoHandlerFoundException<br>
등 여러가지가 있어서 때에 맞춰 쓰는게 좋습니다.<br>
외우기 귀찮으면 AI에게 물어보는게 빠릅니다.<br>
<br>

<h2>데이터 추가 할때 예외처리</h2>
Service 에서 if 로 조건을 확인하고 Exception 으로 예외를 날리는 방법도 있지만<br>
Springboot 에서는 JPA 에서 Bean Validation (@Valid) 를 주로 사용한다.<br>
ex) <code>@NotBlank(message = "제목은 비워둘 수 없습니다") @Size(max = 50, message = "제목은 최대 50자까지 가능합니다")</code><br>
이 경우 Controller 에서는 BindingResult 를 매개변수로 받고 <code>bindingResult.hasErrors()</code> 로 에러를 확인할 수 있다.<br>
위의 message 는 <code>bindingResult.getAllErrors().forEach(error -&gt; { System.out.println(error.getDefaultMessage()); });</code> 의 방법으로 확인 하능하다.<br>
html 에서는 Thymeleaf를 사용하는 경우 <code>&lt;div th:if="${#fields.hasErrors('title')}" th:errors="*{title}"&gt;&lt;/div&gt;</code> 의 방법으로 사용 가능하다.
<br>

</body>
</html>