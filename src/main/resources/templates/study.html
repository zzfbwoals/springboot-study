<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Springboot 공부</title>
    <link rel="stylesheet" href="/styles.css">
</head>
<body>

<h2>REST API</h2>
1. Unifrom Interface: 비슷한 기능을 하는 API들은 URL과 method가 유사성, 일관성이 있어야 함.<br>
2. Client-server 역할 구분: 유저에게 서버역할을 맡기거나 DB를 직접 입출력하게 시키면 안좋음.<br>
3. Stateless: 요청들은 서로 의존성이 있으면 안되고 각각 독립적으로 처리.<br>
4. Cacheable: 서버가 보내는 자료들은 캐싱이 가능해야 함. 자주 받는 자료들은 브라우저에서 하드에 저장해놓고 서버에 요청을 날리는게 아니라 하드에서 뽑아쓰는 것이 캐싱.<br>
5. Layered System: 서버 기능을 만들 때 레이어를 걸쳐서 코드가 실행되도록 만들어도 됨.<br>
6. Code on demand: 서버는 실행가능한 코드를 보낼 수 있음.<br>
<br>

<h2>예쁜 URL 만들기</h2>
1. 동사보단 명사 위주로 구성<br>
2. 띄어쓰기는 언더바_대신 대시-기호-사용<br>
3. 파일 확장자 쓰지 말기 (.html)<br>
4. 하위 항목을 표현하고 싶으면 / 기호 사용<br>
ex) facebook.com/bbc/photos -> 페북에서 bbc 계정의 사진첩 보여줄거 같음<br>
<br>

<h2>Dependency Injection</h2>
@Autowired는 ItemRepository, ItemService 이름의 타입만 붙여둔 자리에 <br>
new ItemRepository(), new ItemService() 알아서 찾아와서 넣으라는 스프링 문법입니다. <br>
<br>
<h3>다른 클래스의 함수 사용하려면</h3>
new ItemService().saveItem() 해서 사용하면 뭔가 비효율적인 것 같지 않습니까<br>
왜냐면 /add로 요청이 들어올 때 마다 매번 new 키워드로 object를 뽑아야하니까요.<br>
그게 싫으면 그냥 object를 한 번 뽑고 그걸 변수에 저장해뒀다가 계속 재사용하는 식으로 코드짜도 됩니다.<br>
근데 그걸 여러분이 직접 코드로 구현해도 되겠지만 스프링에게 시킬 수도 있습니다.<br>
3-step이 필요한데<br>
1. 클래스에 @Service 붙여놓고<br>
2. 이 함수들 쓰고싶은 곳에 가서 변수로 등록하고<br>
3. 원하는 곳에서 변수.함수() 쓰면 됩니다.<br>
<br>
이런 식으로 코드짜는 패턴을 멋있는 개발자말로 dependency injection이라고 합니다. <br>
다른 클래스의 변수, 함수를 사용할 때 <br>
new 클래스().함수() 이렇게 매번 쓰는게 아니라 <br>
new 클래스()를 다른데서 미리 뽑아놓은 다음에 <br>
그것만 파라미터로 집어넣어서 쓰게 만드는걸 dependency injection이라고 부릅니다. <br>
<br>
장점1. 매번 object를 뽑아쓰지 않아도 되니까 성능상 효율적임 <br>
이러면 API가 실행될 때 마다 object를 새로 뽑을 필요가 없습니다. <br>
object를 하나만 뽑아놓고 계속 재사용하는걸 싱글톤 패턴이라고 부르기도 합니다. <br>
<br>
장점2. 클래스간의 연결고리를 줄일 수 있습니다. <br>
클래스간의 커플링을 줄여서 클래스들을 서로 독립적으로 깔끔하게 유지할 수 있어서 쓰는 이유도 있습니다. <br>
클래스1에서 new 클래스2(); 하면 클래스간에 커플링이 생긴다고 합니다. <br>
이러면 나중에 클래스2가 변경되면 그걸 쓰는 클래스1도 찾아가서 변경해야합니다. <br>
그래서 커플링을 줄이면 관리가 편해질 수 있습니다. <br>
<br>

<h2>Container, Bean이라는 용어 </h2>
스프링이 몰래 object를 하나 뽑아서 알아서 집어넣어준다고 했는데<br>
근데 스프링이 object를 뽑아서 보관하는 공간 같은게 있을 것이다.<br>
그걸 Container 아니면 IOC Container라고 부릅니다.<br>
거기 안에 들어있는 object들을 Spring의 Bean이라고 부릅니다.<br>
<br>
참고로 @Service, @Component 이런걸 클래스에 붙여놓으면<br>
"서버가 실행될 때 @Service, @Component 붙은 클래스의 object를 뽑아서 Container안에 담아놓으라"는 뜻입니다.<br>
그리고 그 때 스프링이 뽑아준 object가 Bean입니다.<br>
<br>

<h2>여러가지 Exception</h2>
RuntimeException 보다 더 정확한걸 쓰는게 좋은데<br>
들어온 값이 더러우면 MethodArgumentNotValidException, IllegalArgumentException<br>
URL이 이상하면 MissingServletRequestParameterException, NoHandlerFoundException<br>
등 여러가지가 있어서 때에 맞춰 쓰는게 좋습니다.<br>
외우기 귀찮으면 AI에게 물어보는게 빠릅니다.<br>
<br>

<h2>데이터 추가 할때 예외처리</h2>
Service 에서 if 로 조건을 확인하고 Exception 으로 예외를 날리는 방법도 있지만<br>
Springboot 에서는 JPA 에서 Bean Validation (@Valid) 를 주로 사용한다.<br>
ex) <code>@NotBlank(message = "제목은 비워둘 수 없습니다") @Size(max = 50, message = "제목은 최대 50자까지 가능합니다")</code><br>
이 경우 Controller 에서는 BindingResult 를 매개변수로 받고 <code>bindingResult.hasErrors()</code> 로 에러를 확인할 수 있다.<br>
위의 message 는 <code>bindingResult.getAllErrors().forEach(error -&gt; { System.out.println(error.getDefaultMessage()); });</code> 의 방법으로 확인 하능하다.<br>
html 에서는 Thymeleaf를 사용하는 경우 <code>&lt;div th:if="${#fields.hasErrors('title')}" th:errors="*{title}"&gt;&lt;/div&gt;</code> 의 방법으로 사용 가능하다.
<br>

<h2>파일분리?</h2>
예전부터 파일을 Controller, Service, Domain, Repository 이런식으로 구분해서 나누었지만<br>
테이블 기준으로 나누는게 편리하다. 예를 들어 Item 테이블이 있으면 Item 폴더를 만들어서 연관있는 클래스들을 거기에 모은다.<br>
<br>

<h2>조회기능 (GET)</h2>
Repository 를 사용하여 findAll() 과 같은 함수를 사용해서 리스트에 저장해서 반환한다.<br>
REST API 가 아니라 직접 html 로 전달하려면 Thymeleaf 템플릿 + Model 객체 조합을 사용한다.<br>
<br>

<h2>추가기능 (POST)</h2>
받아온 입력한 데이터들을 Repository 의 save() 를 사용하여 저장한다. save 에는 테이블 객체를 넣는다.<br>
테이블 객체를 초기화 하기 위해서는 Builder() 나 Lombok 의 Setter() 를 사용한다.<br>
form 을 사용하면 GET, POST 요청을 날릴 수 있다. 하지만 PUT, DELETE 등은 AJAX 를 사용한다.<br>
<br>

<h2>수정기능 (PUT)</h2>
받아온 입력한 데이터들은 추가기능과 동일하게 진행한다. 단, 수정하려는 데이터의 ID(PK) 값을 알아야한다.<br>
이는 사용자에게 받아오거나 DB 에서 찾는 방법이 있다. ID(PK) 값을 알았으면 해당 ID 값을 가진 데이터에 덮어쓰기 처럼 다시 저장하면 수정완료.<br>
<br>

<h2>삭제기능 (DELETE)</h2>


<h2>AJAX</h2>
우리가 웹페이지에서 서버에 요청을 날리고 싶으면 방법이 크게 3개가 있습니다.<br>
1. 주소창에 URL을 집어넣든가 (GET요청가능)<br>
2. form 쓰든가 (GET, POST요청가능) <br>
3. ajax를 쓰든가 (전부가능)<br>
ajax만의 장점이 있는데 ajax쓰면 새로고침 없이도 서버로 요청을 날릴 수 있습니다.<br>
주소창 쓰거나 form 쓰면 항상 자동 새로고침되는데 ajax는 그런거 없어서 몰래 스무스하게 요청을 날릴 수 있습니다.<br>
어떻게 하냐면 자바스크립트로 fetch('/URL~~') 이런걸 쓰면 ajax를 이용해서 GET 요청을 날릴 수 있습니다.<br>
<br>
ajax로 요청 날릴 때 설정을 기입할 수도 있습니다.<br>
- method 속성에 어떤 method로 요청할지 설정도 가능하고<br>
- body 속성에 어떤 데이터를 서버로 보낼지 설정도 가능하고<br>
- headers란에 전송할 데이터의 타입을 설정도 가능하고<br>
- 전송할 데이터가 많으면 자바스크립트 array나 object 안에 담아서 전송해도 됩니다. (자바에서의 List, Map과 유사함)<br>
근데 array나 object자료 전송할 때는 JSON.stringify() 안에 넣어서 전달하고<br>
타입을 application/json로 기입해야 잘 전달됨<br>
<br>
ajax로 application/json 타입의 데이터를 보냈다면<br>
서버에서 출력할 땐 파라미터에 @RequestBody라는거 써주면 되겠습니다.<br>
그리고 변환할 자료형 맘대로 입력하면 되는데<br>
자바스크립트 object 형태로 보냈다면 Map으로 간편하게 변환해서 쓰면 되겠습니다.<br>
<br>
<code>fetch('/abc?데이터이름=데이터값&데이터이름2=데이터값2')  </code><br>
서버로 데이터 전송할 때 저렇게 복잡하게 적기 싫으면<br>
query string이라는 것도 사용가능합니다.<br>
URL에다가 이런 식으로 정보를 숨겨서 요청을 날리면<br>
서버로 진짜로 그 데이터가 전송됩니다.<br>
여러개 전송하려면 & 기호로 연결하면 됩니다.<br>
서버에서 이걸 꺼내고 싶으면 (@RequestParam 타입 데이터이름) 파라미터로 꺼낼 수 있습니다.<br>
폼전송으로 보낸 데이터처럼 똑같이 꺼낼 수 있음<br>
그래서 데이터를 서버로 간단하게 보내고 싶을 때는 query string 써도 됩니다.<br>
<br>
하지만 query string은<br>
- 자료가 길고 복잡하면 여기 적는게 오히려 더러움<br>
- URL에 뭔가를 적는 방식이다보니까 정보가 너무 잘 보여서 코딩 모르는 사람들도 위조하기가 쉬워짐<br>
이런 단점이 있어서 간단하고 안중요한 데이터 전송하는데 쓰는게 좋습니다.<br>
그럼 다음 시간까지 삭제기능 알아서 만들어옵시다.<br>
<br>

<h2>Session</h2>
session 방식을 쓴다면 입장권을 만들 때 한개의 내용만 딱 적어서 보냅니다.<<br>
<br>
로그인 :<br>
1. 유저가 로그인하면 DB에 유저아이디, 유효기간, session id 이런걸 기록해두고<br>
2. 유저에게 입장권을 발급해줄 때 입장권에 session id 하나만 달랑 적어보냅니다.<br>
session id는 그냥 행들을 구분하기 위한 랜덤 문자나 숫자입니다.<br>
<br>
로그인이 필요한 서버기능 이용시 :<br>
1. 유저가 GET/POST 요청시 입장권을 서버에 제출함<br>
2. 서버는 입장권에 써있는 session id를 가지고 DB를 조회해본 다음<br>
DB기록에 별 이상 없으면 GET/POST요청을 진행시켜 줍니다.<br>
<br>
장점은 매번 GET/POST 요청할 때 마다 DB를 조회해보기 때문에<br>
하나하나의 요청마다 엄격하게 유저를 체크해볼 수 있습니다.<br>
<br>
단점은 그 만큼 DB의 부담이 심해질 수 있습니다.<br>
그래서 유저가 많은 사이트들은 Redis같은 빠른 메모리 DB를 이용하기도 합니다.<br>
<br>

<h2>Token (JWT)</h2>
JWT방식을 쓴다면 입장권에 많은 정보를 기록해놔서 DB 조회를 안해도 되게 만듭니다.<br>
<br>
로그인 :<br>
1. 유저가 로그인하면<br>
유저에게 입장권을 발급해줄 때 입장권에 (유저의 아이디, 로그인 날짜, 유효기간) 등을 적어두고 암호화해서 보냅니다.<br>
DB에 뭐 저장하는건 없음<br>
<br>
로그인이 필요한 서버기능 :<br>
1. 유저가 GET/POST 요청시<br>
유저가 입장권을 제출하면 입장권의 유효기간 까보고 별 이상 없으면 통과시켜 줍니다.<br>
유저 정보가 필요하면 입장권에 써있는걸 꺼내서 사용합니다.<br>
<br>
Q. 유저가 JWT를 맘대로 위조하면 어쩔것임?<br>
근데 JWT를 만들 때 여러 정보들을 짧은 문자로 변환을 해서 만드는데 (일명 hashing)<br>
변환할 때 암호를 넣을 수 있어서 암호가 변경되거나 내용이 변경되면 짧은 문자도 변하기 때문에<br>
위조여부를 쉽게 알 수 있어서 걱정은 안해도 됩니다.<br>
<br>
JWT의 장점은 매번 GET/POST 요청할 때 마다 DB를 조회할 필요가 없어서 DB 부담이 적습니다.<br>
그래서 유저가 매우 많거나 마이크로서비스형태로 서버를 여러개 운영하는 사이트들이 즐겨쓰는 경향이 있습니다.<br>
단점은 유저의 JWT를 나쁜 사람이 훔쳐가면 그 사람의 로그인을 막거나 할 수 있는 방법이 없습니다.<br>
그리고 다른 컴퓨터에 저장된 JWT를 소멸시키거나 그럴 수는 없기 때문에 다른 컴퓨터를 로그아웃시키기도 어려울 수 있습니다.<br>
물론 나쁜 JWT들을 모아서 DB 같은 곳에 기록해두면 되는데<br>
그러면 매번 JWT 사용마다 DB를 조회해야하니 session 방식과 딱히 다른 점이 없음<br>
<br>

<h2>OAuth</h2>
OAuth는 입장권같은건 아니고 OAuth의 뜻은<br>
어떤 유저의 A 사이트의 사용권한을 B 사이트를 운영하는 내가 잠깐 빌릴 수 있는데<br>
그 과정을 정의하는 규칙같은겁니다.<br>
그래서 OAuth를 잘 이용하면<br>
유저의 A 사이트 회원정보를 가져와서 내가 운영하는 B 사이트 회원가입시 사용할 수도 있고<br>
이걸 흔히 소셜로그인이라고 부릅니다.<br>
<br>
예를 들어 코딩애플이라는 사이트를 운영하는데 구글로그인을 구현하고 싶으면 어떤 식으로 이루어지냐면<br>
1. 유저가 코딩애플 사이트에서 구글 로그인 버튼을 누르면 구글 계정으로 로그인하라고 뜨는데 로그인합니다.<br>
2. "수상한 코딩애플 사이트로 느그 개인정보 전송해도 되냐"고 구글이 물어봅니다.<br>
3. 유저가 허락하면 허락했다고 구글 -> 코딩애플서버 이렇게 알림을 전송합니다.<br>
4. 알림이 도착하면 코딩애플서버는 구글에게 유저 정보를 요청해서 받아옵니다.<br>
<br>
거기엔 { 유저이메일, 이름, access_token, 유효기간 } 이런 것들이 들어있습니다.<br>
그 정보들로 JWT 만들어서 사용하거나 session 으로 DB에 저장해두거나 마음대로 한 다음<br>
코딩애플 사이트 로그인기능 구현시 사용하면 됩니다.<br>
<br>

</body>
</html>